setwd("~/../external/irdpackage")
setwd("~../external/irdpackage")
setwd("~..")
getwd()
setwd("~/0. Semestres/SS2025/Sensitivity-Analysis-and-Surrogate-Modeling-of-PEM-Fuel-Cells/tests")
#--- setup ----
setwd("../external/irdpackage")
library("mlr3")
library("mlr3learners")
library("iml")
library("mlr3pipelines")
library("devtools")
load_all()
#--- load the data ----
data_pc = read.csv("../../data/raw/data_for_classification_up_until_010625.csv", stringsAsFactors = TRUE)
data_pc$id = NULL
View(data_pc)
#--- load the data ----
data_pc = read.csv("../../data/raw/complete_data/data_for_classification_up_until_010625.csv",
stringsAsFactors = TRUE)
#--- load the data ----
data_pc = read.csv("../../data/raw/complete_data/data_for_classification_up_until_020625.csv",
stringsAsFactors = TRUE)
data_pc$id = NULL
View(data_pc)
# rename the target col to a more specific name
names(data_pc)[names(data_pc) == "classification"] = "validity"
# just making sure it's treated as a factor
data_pc$validity = factor(data_pc$validity, levels = c("invalid", "valid"))
x_interest = data.frame(
Tfc         = 347.15,    # Cell temperature [K]
Pa_des      = 2.0*1e5,   # Anode pressure [Pascal]
Pc_des      = 2.0*1e5,   # Cathode pressure [Pascal]
Sa          = 1.2,       # Anode stoichiometry
Sc          = 2.0,       # Cathode stoichiometry
Phi_a_des   = 0.4,       # Desired RH anode
Phi_c_des   = 0.6,       # Desired RH cathode
epsilon_gdl = 0.701,     # GDL porosity
tau         = 1.02,      # Pore structure coefficient
epsilon_mc  = 0.399,     # Ionomer volume fraction in CLs
epsilon_c   = 0.271,     # GDL compression ratio
e           = 5.0,       # Capillary exponent
Re          = 5.7e-7,    # Electron conduction resistance [Ω·m²]
i0_c_ref    = 2.79,      # Ref. cathode exchange current density [A/m²]
kappa_co    = 27.2,      # Crossover correction coefficient
kappa_c     = 1.61,      # Overpotential correction exponent
a_slim      = 0.056,     # s_lim coefficient (bar⁻¹)
b_slim      = 0.105,     # s_lim coefficient (dimensionless)
a_switch    = 0.637      # s_lim switching point
)
# add dummy label to match task structure (won't affect box finding)
x_interest$validity = factor("valid", levels = c("invalid", "valid"))
#--- define task and model ----
task = TaskClassif$new(id = "pem", backend = data_pc, target = "validity")
#---- split data into train/test ----
set.seed(42)
train_idx = sample(task$nrow, 0.8 * task$nrow)  # 80% train
test_idx = setdiff(seq_len(task$nrow), train_idx)
# train and test tasks
task_train = task$clone()$filter(train_idx)
task_test  = task$clone()$filter(test_idx)
# train model on training set
mod$train(task_train)
#--- define task and model ----
task = TaskClassif$new(id = "pem", backend = data_pc, target = "validity")
# # use a random forest, we want probabilities out of it
mod = lrn("classif.ranger", predict_type = "prob")
#--- define task and model ----
set.seed(42)
task = TaskClassif$new(id = "pem", backend = data_pc, target = "validity")
# use a random forest, we want probabilities out of it
mod = lrn("classif.ranger", predict_type = "prob")
mod$train(task)
#---- split data into train/test ----
set.seed(42)
train_idx = sample(task$nrow, 0.8 * task$nrow)  # 80% train
test_idx = setdiff(seq_len(task$nrow), train_idx)
# train and test tasks
task_train = task$clone()$filter(train_idx)
task_test  = task$clone()$filter(test_idx)
# train model on training set
mod$train(task_train)
# predict on test set
prediction = mod$predict(task_test)
# basic performance metrics
prediction$score(msrs(c("classif.acc",      # Accuracy
"classif.precision", # Precision
"classif.recall",    # Recall
"classif.fbeta",     # F1-score
"classif.auc"        # AUC (requires prob output)
)))
#--- create predictor object ----
pred = Predictor$new(model = mod,
data = data_pc,
y = "validity",
type = "classification",
class = "valid")
mair = Maire$new(predictor = pred,
num_of_iterations = 100L,
convergence = TRUE,
quiet = FALSE,
strategy = "traindata")
system.time({
mairb = mair$find_box(x_interest = x_interest, desired_range = c(0.9, 1.0))
})
tensorflow::tf$compat$v1$disable_eager_execution()
mair = Maire$new(predictor = pred,
num_of_iterations = 100L,
convergence = TRUE,
quiet = FALSE,
strategy = "traindata")
system.time({
mairb = mair$find_box(x_interest = x_interest, desired_range = c(0.9, 1.0))
})
mairb$evaluate()
mairb$plot_surface(feature_names = c("Tfc", "Pa_des"), surface = "range")
#--- postprocess MAIRE box ----
postproc = PostProcessing$new(predictor = pred, subbox_relsize = 0.1)
post_box = postproc$find_box(x_interest = x_interest,
desired_range = c(0.9, 1.0),
box_init = mairb$box)
post_box$evaluate()
post_box
View(post_box)
post_box$plot_surface(feature_names = c("Tfc", "Pa_des"), surface = "range")
post_box$plot_surface(feature_names = c("Tfc", "Pa_des"), surface = "range")
pred$predict(x_interest)
#----------------------------------------------------------------
# Option 2: compute regional descriptor with MaxBox
#----------------------------------------------------------------
set.seed(42)
mb = MaxBox$new(predictor = pred, quiet = FALSE, strategy = "traindata")
system.time({
mbb = mb$find_box(x_interest = x_interest, desired_range = c(0.9, 1.0))
})
mbb$evaluate()
mbb$plot_surface(feature_names = c("Tfc", "Pa_des"), surface = "range")
#--- postprocess MaxBox box to refine ----
postproc_maxbox = PostProcessing$new(predictor = pred)
post_box_maxbox = postproc_maxbox$find_box(x_interest = x_interest,
desired_range = c(0.9, 1.0),
box_init = mbb$box)
post_box_maxbox$evaluate()
print(post_box_maxbox)
prim = Prim$new(predictor = pred)
prim_box = prim$find_box(x_interest = x_interest, desired_range = c(0.9, 1.0))  # we want mostly valid
prim_box$evaluate()  # initial evaluation
#--- postprocess PRIM box ----
postproc_prim = PostProcessing$new(predictor = pred)
post_box_prim = postproc_prim$find_box(x_interest = x_interest,
desired_range = c(0.9, 1.0),
box_init = prim_box$box)
post_box_prim$evaluate()
post_box_prim
